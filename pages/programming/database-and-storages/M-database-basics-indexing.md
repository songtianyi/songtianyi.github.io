# 数据库基础-索引

作者: [songtianyi](http://songtianyi.info)

## 前言

什么是索引？通过数组的下标获得指定的值是索引，同样的，通过 map 的 key 取得 value 是索引。这些是我们在编码的时候
较常遇到的几种索引方式。它们都属于 `key --> value` 的结构。

``` c
i --> array[i]
p --> *p
key --> map[key]
```

数据库索引也一样，解决的问题本质是相同的，通过 key 快速定位到 value。相较于我们平时使用的索引，数据库索引解决的问题更复杂，因为数据库存储的内容可能在内存中，但大部分是在磁盘上，而且要应对大量的并发读写请求，实现起来十分复杂。

## 索引类型

根据数据类型，业务类型的不同，数据库索引的实现也是多种多样的，像 postgres 就有 B-Tree, Hash, GiST, SP-GiST, GIN, BRIN 等多种不同的索引类型。我们比较常听到的是 B-Tree, B+-Tree，因为它们的适用范围更广。但面对特定的场景，比如全文搜索，GIN, GiST 的表现效果要更好。

### Hash 索引

hash 索引相对来说简单，而且在合适的场景效果突出。
如下，我们有一张表结构及数据项:

| Name  | Age  |
| :---- | :--: |
| Arjen | 16 |
| Baron | 21 |
| Peter | 45 |

我们可以建立 `Name` 到行的索引，key 是 `Name` , value 是行指针。先将 `Name` 转换成数字:

``` 

hash('Arjen')= 2323
hash('Baron')= 7437
hash('Peter')= 8784
```

然后将 hash 后的值作为 key 指向行指针

| Name hash code  | Row pointer  |
| :---- | :--: |
| 2323 | row_1_pointer |
| 7437 | row_2_pointer |
| 8784 | row_3_pointer |

对整形的 key 排序，然后使用二分查找，这样我们在通过 `Name` 查询数据的时候就会非常快。

``` sql
db> SELECT * FROM t WHERE name='Peter';
```

数据库在查找的时候首先会讲 Peter 转换为整形，然后使用二分查找拿到对应的行指针，之后读取到整行的内容。

上面的做法，有一些问题:

1. 不好排序，Name 转成 整形之后，是按照转换后的值来排序的，所以没办法借助索引就行排序
2. 假如我们针对 `Name` 和 `Age` 这两列一起做 hash，即 hash(Name, Age), 那么当 **WHER** 条件只有 `Name` 的时候是无法使用这个索引的
3. hash 只支持等值查询，即 `=`,      `IN`等等，不支持任何范围查询，比如 `Name > 100`
4. hash 冲突比较多的时候，效果会大打折扣，存储引擎必须遍历链表中的所有行指针，而且索引维护的成本会很高。一种优化方式是增大 hash 空间，比如将 hash 值从 32 位扩大到 64 位

Hash 索引可以和其他索引结合起来使用，比如，在分布式存储中用来定位存储节点，在分库分表的场景下，用来定位库和表。

### B Tree
