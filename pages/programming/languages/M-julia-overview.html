<!DOCTYPE html>
<html>
<head>
<title>M-julia-overview.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="julia-%E6%A6%82%E8%A7%88">Julia 概览</h1>
<p>作者: <a href="https://github.com/songtianyi">songtianyi</a> 2018-08-14</p>
<h3 id="%E5%89%8D%E8%A8%80">前言</h3>
<p><code>1 分钟</code></p>
<p>机器学习的热度一直不减，其相关技术必然是未来程序猿的必修课，要学就趁早。在深度学习领域，python 应该是不二之选，python 作为一门胶水语言，拥有极其丰富的第三方库，不管解决什么问题，它都应该是比较快的工具，值得大家学习。Julia 是一个面向科学计算的高性能动态高级程序设计语言，其语法与其他科学计算语言(Matlab)相似，而且在许多情况下拥有能与编译语言相媲美的性能。值得一提的是，tensorflow 和 mxnet 都有 julia 的 binding，对于新手，可以尝试用 julia 打开机器学习的大门, 作为老手，学习一门新语言，也能打开视野，为未来的技术变迁做储备。在开始之前，请先掌握<a href="M-how-to-choose-your-programming-language.md">语言选型</a>里的概念。</p>
<h3 id="julia-%E6%98%AF%E4%BB%80%E4%B9%88">Julia 是什么</h3>
<blockquote>
<p>Julia is a highly productive language that runs fast</p>
</blockquote>
<ul>
<li>
<p>快</p>
<p>性能是 julia 设计的初衷。科学计算需要大量的性能开销，主流的 python 并不能满足这一要求，但 julia 的设计者们仍然认为动态语言是更好的选择，得益于技术的进步，动态语言可以达与静态语言相媲美的性能，于是 julia 在 2012 年诞生了(python 诞生于 1991)</p>
</li>
<li>
<p>动态类型</p>
</li>
<li>
<p>optional typing</p>
<p>通常，动态语言的变量类型都是在运行时确定的，但对于 julia 来说是可选的，你可以在代码中申明类型，利用 JIT，julia 可以编译部分代码以提高性能，这些声明为 JIT 提供了用于优化性能的信息。Julia 提供了预编译的选项 <code>__precompile__()</code>。</p>
</li>
<li>
<p>多重派发(multiple dispatch)</p>
<p>类似于静态语言的函数重载，julia 在处理同名函数时使用的方法叫多重派发。多重派发是 julia 的核心特性。</p>
</li>
<li>
<p>多范式，IP,PP,OOP,FP,MP</p>
</li>
<li>
<p>通用性</p>
<p>虽然 Julia 是为科学计算而设计的，但也注重在其他领域的应用，所以在语法设计上不仅参考了 R, MATLAB, Python，也同时吸取了 Lisp, Perl, Lua, Ruby 等语言的优点。</p>
</li>
<li>
<p>coroutine(Task)</p>
</li>
<li>
<p>可以直接调用 C，没有额外的封装</p>
</li>
<li>
<p>支持宏</p>
</li>
</ul>
<h5 id="jit">JIT</h5>
<p>即时编译(Just-In-Time)技术或者叫即时编译器。我们知道，静态语言是通过编译器将源码编译成机器码来执行的，只需编译一次；动态语言是通过解释器在程序运行时一句句边翻译边运行的，同一段代码可能需要翻译多次。即时编译则是两者的结合，即时编译器在运行时逐句翻译代码并执行，并将翻译结果缓存(具体的逻辑依赖于 JIT 的算法实现)，相对于解释器，性能开销要低很多。</p>
<h3 id="%E5%AE%89%E8%A3%85">安装</h3>
<p>在官方<a href="https://julialang.org/downloads/">Dowload</a>页面下载指定平台的安装包或者二进制包，本文使用的版本为<code>0.6.4</code>, julia 还在快速迭代中，不同版本之间会有差异。安装好之后，可以直接执行，它会启动一个和 python 一样的交互式的 shell(repl):</p>
<pre class="hljs"><code><div>./julia
</div></code></pre>
<p>也可以用它来执行 julia 代码:</p>
<pre class="hljs"><code><div>julia demo.jl
</div></code></pre>
<p>在此之前，你可能需要把 julia 二进制加入环境变量中，比如 macOS 下:</p>
<pre class="hljs"><code><div>JULIA="/Applications/Julia-0.6.app/Contents/Resources/julia/bin/"
export PATH=$PATH:$JULIA
</div></code></pre>
<p>更多的用法请查看它的 help 文档。</p>
<h3 id="%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">类型系统</h3>
<table>
<thead>
<tr>
<th style="text-align:center">Lang</th>
<th style="text-align:center">Typed</th>
<th style="text-align:center">Static and dynamic  checks</th>
<th style="text-align:center">Strongly checked</th>
<th style="text-align:center">Weakly or strongly  typed</th>
<th style="text-align:center">Dynamically or statically typed</th>
<th style="text-align:center">Type theories</th>
<th>Paradigms</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Julia</td>
<td style="text-align:center">☑️</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">☑️</td>
<td style="text-align:center">weakly</td>
<td style="text-align:center">dynamically</td>
<td style="text-align:center">generic, overloading, subtype</td>
<td>IP,SP,PP,OOP,FP,MP</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><em>dynamic checks</em>: Julia 是动态语言，只有动态检查，所谓的编译也是发生在运行时的。</p>
</li>
<li>
<p><em>strongly checked</em>: 关于类型系统的安全性检查，一直是一个比较难界定的问题，julia 的 commiter 认为 julia 属于 strongly checked 的语言 <sup>[2]</sup>, 他给出的理由是:</p>
<ul>
<li>
<p>没有指针运算</p>
</li>
<li>
<p>没有类型双关(type punning)</p>
<blockquote>
<p>关于类型双关，简单来说就是通过一些奇技淫巧(通常是用指针操作内存)，绕过语言的类型系统，从而达到用该语言语法难以实现甚至不可能达到的效果, 这在 C 语言里是很常见的。一个安全的类型系统当然是不允许这么做的。类型双关的具体定义可以参考 wikipedia<sup>[3]</sup>, 还是比较容易理解的。</p>
</blockquote>
</li>
</ul>
<p>在<a href="M-how-to-choose-your-programming-language.md">语言选型</a>里讲到过，拥有隐式类型转换的语言属于 weakly checked，我们来看下面的例子:</p>
<pre class="hljs"><code><div>julia&gt; pi + <span class="hljs-number">1</span>
<span class="hljs-number">4.141592653589793</span>
</div></code></pre>
<p>浮点和整形可以相加，julia 进行了隐式类型转换？不是，我们在 repl 里用<code>?</code>加表达式来看看 repl 给我们的解释</p>
<pre class="hljs"><code><div>help?&gt; pi + 1
  +(x, y...)

  Addition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).
</div></code></pre>
<p>说明这里只是语法糖, Julia 称之为<a href="https://docs.julialang.org/en/v0.6.4/manual/conversion-and-promotion/">type promotion</a>。当我们需要类型转换的时候可以使用<code>convert</code>函数。</p>
<pre class="hljs"><code><div>julia&gt; convert(Float64, pi + 1)
4.141592653589793
</div></code></pre>
</li>
<li>
<p><em>weakly typed</em>: 类型是可变的</p>
<pre class="hljs"><code><div>a = <span class="hljs-number">10</span>
a = <span class="hljs-string">"b"</span>
println(a)
</div></code></pre>
</li>
<li>
<p><em>dynamically typed</em>: 类型在运行时确定</p>
<blockquote>
<p>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running.</p>
</blockquote>
</li>
<li>
<p><em>type inference</em>: julia 支持类型推断。需要注意的地方是，在不同 bit 的硬件架构下，推断出的类型会不同</p>
<pre class="hljs"><code><div># 32-bit system:
julia&gt; typeof(1)
Int32

# 64-bit system:
julia&gt; typeof(1)
Int64
</div></code></pre>
</li>
<li>
<p><em>nominative</em>: 意味着类型之间的关系是通过名称和显式的类型关系声明来确定的，和通过类型结构来确定类型关系的 structural type system 相对。</p>
</li>
</ul>
<h3 id="%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA">类型理论</h3>
<h5 id="subtype">subtype</h5>
<p>julia 的类型系统定义了一个类型树(type graph)，根类型是<code>Any</code>, 是所有类型的 super type，叶子类型是<code>Union{}</code>，是所有类型的 subtype，这里只列出数值类型部分:</p>
<p><img src="https://songtianyi-blog.oss-cn-shenzhen.aliyuncs.com/800px-Type-hierarchy-for-julia-numbers.png" alt="type hierarchy for julia numbers"></p>
<p>在这个类型树里 Float64, Int64 等都是 Number 类型的子类，以此为例，我们来看下 julia 的多态的书写形式，很简单:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> print(x ::<span class="hljs-built_in">Number</span>) 
    println(<span class="hljs-string">"this is "</span>, x)
<span class="hljs-keyword">end</span>
print(<span class="hljs-number">1.0</span>::<span class="hljs-built_in">Float64</span>)
print(<span class="hljs-number">4</span>::<span class="hljs-built_in">Int64</span>)
</div></code></pre>
<p>output:</p>
<pre class="hljs"><code><div>1.0
4
</div></code></pre>
<p>julia 的多态属于 nominal subtyping</p>
<h5 id="generic">generic</h5>
<p>julia 的泛型可以应用在复合类型上</p>
<pre class="hljs"><code><div>julia&gt; struct Point{T}
           x::T
           y::T
       end
</div></code></pre>
<p>我们可以通过实例化一个泛型来创建一个新的类型</p>
<pre class="hljs"><code><div>Point{<span class="hljs-built_in">String</span>}
</div></code></pre>
<p>它和不使用泛型的形式的效果是一样的:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">struct</span> Point
  x::<span class="hljs-built_in">String</span>
  y::<span class="hljs-built_in">String</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>而且 Point 本身也是一个类型对象(type object)，它是所有 Point{T}实例的父类型</p>
<pre class="hljs"><code><div>julia&gt; Point{Float64} &lt;: Point
true

julia&gt; Point{AbstractString} &lt;: Point
true
</div></code></pre>
<p>tip: <code>A &lt;: B</code>为真则 A 是 B 的子类型成立</p>
<p>但是 julia 泛型的类型规则属于不变(<em>invariant</em>), 意味着，当<code>Float64 &lt;: Real</code>为真时，<code>Point{Float64} &lt;: Point{Real}</code>并不为真，它不会保持或者逆转之前的类型关系。因此，当泛型实例作为入参类型时会面临一个问题, 比如函数入参类型为 Point{Real}，这时我们不能对它传入 Point{Float64}，验证代码如下:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">struct</span> Point{T}
    x::T
    y::T
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">function</span> norm(p::Point{<span class="hljs-built_in">Real</span>})
    <span class="hljs-keyword">return</span> sqrt(p.x^<span class="hljs-number">2</span> + p.y^<span class="hljs-number">2</span>)
<span class="hljs-keyword">end</span>

println(norm(Point{<span class="hljs-built_in">Real</span>}(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)))
println(norm(Point{<span class="hljs-built_in">Float64</span>}(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>))) <span class="hljs-comment"># MethodError: no method matching norm(::Point{Float64})</span>
</div></code></pre>
<p>解决的方式是，我们用一个类型范围来限定入参类型，而不是一个具体类型:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">struct</span> Point{T}
    x::T
    y::T
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">function</span> norm(p::Point{&lt;:<span class="hljs-built_in">Real</span>}) <span class="hljs-comment"># 所有使用 Real 子类型实例化的 Point{T}都可以作为入参</span>
    <span class="hljs-keyword">return</span> sqrt(p.x^<span class="hljs-number">2</span> + p.y^<span class="hljs-number">2</span>)
<span class="hljs-keyword">end</span>

println(norm(Point{<span class="hljs-built_in">Real</span>}(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)))
println(norm(Point{<span class="hljs-built_in">Float64</span>}(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>))) <span class="hljs-comment"># OK</span>
</div></code></pre>
<p>泛型也可以应用在抽象类型上:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">abstract type</span> Point{T} <span class="hljs-keyword">end</span>
</div></code></pre>
<p>或者基础类型上</p>
<pre class="hljs"><code><div><span class="hljs-keyword">primitive type</span> <span class="hljs-built_in">String</span>{T} <span class="hljs-number">32</span> <span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li><em>overloading</em>: 基于 multiple dispatch 的函数/操作符重载是 julia 的主要特性。<sup>[5]</sup></li>
</ul>
<h3 id="%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83">语法规范</h3>
<h5 id="types">Types</h5>
<h6 id="primitive-types">Primitive types</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128</td>
<td>整形</td>
</tr>
<tr>
<td>Char, String</td>
<td>字符/字符串, String 能够使用下标索引, 注意: Julia 的下标都是从 1 开始的, 1-based. 关于 String 的更多内容可以查看<a href="https://docs.julialang.org/en/v0.6.4/manual/strings/">strings</a></td>
</tr>
<tr>
<td>Bool</td>
<td>真假值</td>
</tr>
<tr>
<td>Float16, Float32,  Float64</td>
<td>IEEE754-2008 浮点,  2.5e-4,  1e10,  0.5f0,  0x1.8p3(16 进制浮点),  Inf32, -Inf32, Inf, -Inf, …, NaN, NaN16</td>
</tr>
<tr>
<td>Any</td>
<td>任意类型</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="composite-types">Composite types</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Complex</td>
<td>复数类型, i 用 im 表示 ex.<code> 0 + 4im</code></td>
</tr>
<tr>
<td>Rational</td>
<td>分数 ex. 6//9, 即 9 分之 6</td>
</tr>
<tr>
<td>function</td>
<td>函数，函数的定义在 julia 有更简洁的方法，ex.  f(x, y) = x + y, 这种写法更贴合科学计算里的公式。当然，函数名也可以是 Unicode 字符， ∑(x,y) = x + y。在 julia 里，算术运算符属于函数的语法糖。</td>
</tr>
<tr>
<td>Tuple</td>
<td>元组，t = (1, 2,&quot;a&quot;)</td>
</tr>
<tr>
<td>Channel</td>
<td>管道，先进先出的队列</td>
</tr>
<tr>
<td>Abstract</td>
<td>抽象类型</td>
</tr>
<tr>
<td>struct</td>
<td>结构体</td>
</tr>
<tr>
<td>mutable</td>
<td>修饰类型的是否可修改</td>
</tr>
<tr>
<td>Union</td>
<td>联合类型</td>
</tr>
<tr>
<td>Nullable</td>
<td>当一个值不确定它是否存在时可以使用 Nullable 来封装它，保证访问的安全性，类似于 Java 的 Optional&lt;T&gt;</td>
</tr>
<tr>
<td>Task</td>
<td>coroutine</td>
</tr>
</tbody>
</table>
<h6 id="%E5%87%BD%E6%95%B0">函数</h6>
<p>在 Julia 里函数是一等公民(first-class objects), 你能够将函数赋值给变量，也可以作为参数和返回值。</p>
<pre class="hljs"><code><div>julia&gt; f = x -&gt; x*x + 2*x - 1
(::#13) (generic function with 1 method)

julia&gt; f(2)
7

julia&gt; g = x -&gt; x^2 + 2x - 1
(::#15) (generic function with 1 method)

julia&gt; g(2)
7
</div></code></pre>
<p>函数的返回值可以为元组</p>
<pre class="hljs"><code><div>julia&gt; f = (x, y) -&gt; (x, y)
(::#25) (generic function with 1 method)

julia&gt; x,y = f(1,2)
(1, 2)
</div></code></pre>
<p>和 python 一样，函数的入参可以带默认值</p>
<pre class="hljs"><code><div>julia&gt; f = (x, y=1) -&gt; x + y
(::#28) (generic function with 2 methods)

julia&gt; f(2)
3
</div></code></pre>
<p>并且支持隐式 return。</p>
<p>当多个函数的逻辑在概念上(conceptual)相同时，我们倾向于使用相同的名称，比如两个类型的想加，会使用<em>add</em>来命名。那么自然就存在一个问题，如何选择要执行的函数？选择要执行的函数的过程称为派发(dispatch)，派发分为三种:</p>
<ul>
<li><em>single-dispatch</em>: 我们调用对象的方法时，比如 obj1.add(a), obj2.add(a')，可以通过对象类型即 obj1, obj2 来决定调用哪个函数, 这种方式称为<em>single-dispatch</em></li>
<li><em>double-dispatch</em>: 有时候，对象的方法需要处理不同的类型，比如 obj1.add(human), obj1.add(animal), 此时需要根据对象类型和方法的参数来确定调用的函数，这种方式称为<em>double-dispatch</em></li>
<li><em>multiple-dispatch</em>: 以此类推，通过对象类型和方法的所有参数类型来确定调用的函数的方式称为<em>multiple-dispatch</em></li>
</ul>
<p>julia 使用 mutiple dispatch。</p>
<h6 id="tuple">Tuple</h6>
<p>和泛型不同的是，Tuple 的类型规则是协变(<em>covariant</em>), 意味着，如果有 <code>Int32 &lt;: Number</code>，那么<code>Tuple{Int32} &lt;: Tuple{Number}</code> 为真，</p>
<h6 id="channel">Channel</h6>
<p>Julia 的 Channel 和 Go 的 chan 在使用上基本是一致的。</p>
<ol>
<li>
<p>创建一个没有 buffer 的 channel, channel 的写入会被阻塞，直到有人读取它。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// go</span>
ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)
</div></code></pre>
<pre class="hljs"><code><div>// julia
ch = <span class="hljs-built_in">Channel</span>(<span class="hljs-number">0</span>)
</div></code></pre>
</li>
<li>
<p>创建一个带 buffer 的 channel</p>
<pre class="hljs"><code><div><span class="hljs-comment">// go</span>
ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)
</div></code></pre>
<pre class="hljs"><code><div>// julia
ch = Channel(10)
</div></code></pre>
</li>
<li>
<p>使用 put!和 take!来写入和读取数据, 和 golang 的区别是，julia 的 channel 在定义时可以不指定类型，默认为<code>Any</code>，意味着可以写入任意类型的数据。</p>
<pre class="hljs"><code><div>ch = <span class="hljs-built_in">Channel</span>{<span class="hljs-built_in">String</span>}(<span class="hljs-number">10</span>)
put!(ch, <span class="hljs-string">"Hello"</span>)
put!(ch, <span class="hljs-string">"World"</span>)
take!(ch)
take!(ch)
</div></code></pre>
</li>
<li>
<p>关闭 channel。julia 的 channel 在关闭后仍然可以读取数据，直到为空。</p>
<pre class="hljs"><code><div>close(ch)
</div></code></pre>
</li>
<li>
<p>判断是否有数据</p>
<pre class="hljs"><code><div>isready(ch)
</div></code></pre>
</li>
<li>
<p>比 go chan 方便的地方是，Channel 提供了 fetch 函数，fetch 只会读取数据，不会 remove 掉数据</p>
</li>
<li>
<p>Channel 可以和一个函数相绑定, 其接受一个匿名函数，并调用它，调用匿名函数时传入一个新建的 channel，一般匿名函数会操作这个 channel，最后会将这个 channel 返回。</p>
<pre class="hljs"><code><div>chnl = <span class="hljs-built_in">Channel</span>(c-&gt;foreach(i-&gt;put!(c,i), <span class="hljs-number">1</span>:<span class="hljs-number">4</span>));
</div></code></pre>
<p>这里的<code>foreach</code>接收一个匿名函数和一个可迭代的对象，foreach 将对象的每一个迭代值都应用到匿名函数上。</p>
</li>
</ol>
<h6 id="abstract-type">Abstract type</h6>
<p>抽象类型在 julia 的类型系统中起到构建类型树(type graph)，复用逻辑和实现多态的作用。类型树的根类型是<code>Any</code>, 任意类型都是它的子类型(subtype), 叶子类型是<code>Union{}</code>, 和<code>Any</code>相反，任意类型都是<code>Union{}</code>的父类型。我们来看下，julia 的数值类型部分的类型树:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">abstract type</span> <span class="hljs-built_in">Number</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">abstract type</span> <span class="hljs-built_in">Real</span>     &lt;: <span class="hljs-built_in">Number</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">abstract type</span> <span class="hljs-built_in">AbstractFloat</span> &lt;: <span class="hljs-built_in">Real</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">abstract type</span> <span class="hljs-built_in">Integer</span>  &lt;: <span class="hljs-built_in">Real</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">abstract type</span> <span class="hljs-built_in">Signed</span>   &lt;: <span class="hljs-built_in">Integer</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">abstract type</span> <span class="hljs-built_in">Unsigned</span> &lt;: <span class="hljs-built_in">Integer</span> <span class="hljs-keyword">end</span>
</div></code></pre>
<p>数值类型的根是<code>Number</code>, 之后由它逐步构建出所有的数值类型。</p>
<p>tip: <code>A &lt;: B</code>为真则 A 是 B 的子类型成立</p>
<pre class="hljs"><code><div>julia&gt; if Int64 &lt;: Number
         println(&quot;hello&quot;)
       end
hello
</div></code></pre>
<h6 id="struct">Struct</h6>
<p>struct 的定义, 初始化及访问都是标准的方式:</p>
<pre class="hljs"><code><div>julia&gt; struct Foo
           bar
           baz::Int
           qux::Float64
       end
       
julia&gt; foo = Foo(&quot;Hello, world.&quot;, 23, 1.5)
Foo(&quot;Hello, world.&quot;, 23, 1.5)

julia&gt; foo.bar
&quot;Hello, world.&quot;
</div></code></pre>
<p>不指定类型的字段，默认类型为<code>Any</code>。特殊的地方是，struct 默认是不能修改的:</p>
<pre class="hljs"><code><div>julia&gt; foo.bar = 1
ERROR: type Foo is immutable
</div></code></pre>
<p>只能通过它的构造器重新初始化。要使其可修改需要显式地声明<code>mutable</code>, mutable struct 会分配在堆内存上。</p>
<h6 id="union">Union</h6>
<p>定义和初始化都比较常规</p>
<pre class="hljs"><code><div>julia&gt; IntOrString = Union{Int,AbstractString}
Union{AbstractString, Int64}

julia&gt; 1 :: IntOrString
1

julia&gt; &quot;Hello!&quot; :: IntOrString
&quot;Hello!&quot;
</div></code></pre>
<h6 id="mutable">mutable</h6>
<p>这里只说下 julia 的值传递规则，对于不可修改的对象，在赋值或者作为入参时是值传递(copy), 可修改的对象是通过指针传递(sharing via pointers), 特别的，不可修改的大内存对象也是指针传递。<sup>[4]</sup></p>
<h6 id="nullable">Nullable</h6>
<p>Nullable<T>, 作用和 Java 里的 Optional<T>是一致的，比如函数的返回值不确定是否为空时，可以使用 Nullable 包裹一下再返回，这样返回值的接收者可以安全地处理它。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> calc() ::<span class="hljs-built_in">Nullable</span>{<span class="hljs-built_in">Int64</span>}
    <span class="hljs-comment"># return 1</span>
    <span class="hljs-comment"># no return</span>
    <span class="hljs-comment"># return Nullable(1)</span>
<span class="hljs-keyword">end</span>

v = calc()
<span class="hljs-keyword">if</span> !isnull(v)
    println(get(v))
<span class="hljs-keyword">end</span>
</div></code></pre>
<h6 id="task">Task</h6>
<p>可以将函数用 Task 包裹起来，通过 Task 的接口，控制任务的执行。</p>
<pre class="hljs"><code><div>julia&gt; a1() = det(rand(1000, 1000));

julia&gt; b = @task a1();

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true
</div></code></pre>
<h5 id="variables">Variables</h5>
<p>julia 的变量比较特殊的地方是，它可以用 Unicode(UTF-8)作为名字, 因为科学计算中有很多特殊的数学符号。</p>
<pre class="hljs"><code><div>julia&gt; δ = 0.00001
1.0e-5

julia&gt; 안녕하세요 = &quot;Hello&quot;
&quot;Hello&quot;
</div></code></pre>
<p>有一个问题是，这些特殊符号怎么输入？在 julia 的 repl 中，可以用<code>\</code>加单词打印出特殊字符，比如上述的<code>δ</code>符号，英文名叫 delta, 在 repl 里输入:</p>
<pre class="hljs"><code><div>julia&gt; \delta
</div></code></pre>
<p>然后按 tab 键，即可打印出<code>δ</code>。</p>
<p>为了科学计算的便利，julia 内置了很多常量和函数, 比如<code>pi</code>, <code>sqrt</code>等，且可以修改它们。</p>
<pre class="hljs"><code><div>julia&gt; pi
 π = 3.1415926535897...

julia&gt; pi = 3
WARNING: imported binding for pi overwritten in module Main
3

julia&gt; pi
3

julia&gt; sqrt(100)
10.0

julia&gt; sqrt = 4
WARNING: imported binding for sqrt overwritten in module Main
4

</div></code></pre>
<p>另外，变量的定义称为变量绑定，变量没有类型，值有类型，变量名和值是绑定关系。我们可以从类型的声明上来窥探出这一点, 在 C 里面给变量声明一个类型并初始化可以这样写:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// c</span>
<span class="hljs-keyword">float</span> a = <span class="hljs-number">8</span>;
</div></code></pre>
<p>在 Julia 里这样写:</p>
<pre class="hljs"><code><div>a = 8 ::Float32
</div></code></pre>
<p>唉？不对，repl 报错了</p>
<pre class="hljs"><code><div>julia&gt; a = 1 ::Float32
ERROR: TypeError: typeassert: expected Float32, got Int64
</div></code></pre>
<p>编译器认为 1 是 Int64, 而我们尝试给它指定一个 Float32 的类型，所以报错了，说明 1 这个值已经有了自己的类型，赋值操作仅仅是将变量名和值进行绑定。</p>
<p>tip: 全局变量不能声明类型。</p>
<h5 id="operators">Operators</h5>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+x</code></td>
<td>unary plus</td>
<td><code>+(1,2,3)=6</code></td>
</tr>
<tr>
<td><code>-x</code></td>
<td>unary minus</td>
<td>如果-x = y , 则必然 y + x = 0, 用来表示负数的</td>
</tr>
<tr>
<td><code>x + y</code></td>
<td>binary plus</td>
<td>performs addition</td>
</tr>
<tr>
<td><code>x - y</code></td>
<td>binary minus</td>
<td>performs subtraction</td>
</tr>
<tr>
<td><code>x * y</code></td>
<td>times</td>
<td>performs multiplication</td>
</tr>
<tr>
<td><code>x / y</code></td>
<td>divide</td>
<td>performs division</td>
</tr>
<tr>
<td><code>x \ y</code></td>
<td>inverse divide</td>
<td>equivalent to <code>y / x</code></td>
</tr>
<tr>
<td><code>x ^ y</code></td>
<td>power</td>
<td>raises <code>x</code> to the <code>y</code>th power</td>
</tr>
<tr>
<td><code>x % y</code></td>
<td>remainder</td>
<td>equivalent to <code>rem(x,y)</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>!x</td>
<td>negation</td>
<td>changes <code>true</code> to <code>false</code> and vice versa</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>~x</code></td>
<td>bitwise not</td>
<td></td>
</tr>
<tr>
<td><code>x &amp; y</code></td>
<td>bitwise and</td>
<td></td>
</tr>
<tr>
<td><code>x | y</code></td>
<td>bitwise or</td>
<td></td>
</tr>
<tr>
<td><code>x ⊻ y</code></td>
<td>bitwise xor (exclusive or)</td>
<td></td>
</tr>
<tr>
<td><code>x &gt;&gt;&gt; y</code></td>
<td><a href="https://en.wikipedia.org/wiki/Logical_shift">logical shift</a> right</td>
<td>整体向右移动，并在左边补 0</td>
</tr>
<tr>
<td><code>x &gt;&gt; y</code></td>
<td><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">arithmetic shift</a> right</td>
<td>整体向右移动，并在最高位填充符号位</td>
</tr>
<tr>
<td><code>x &lt;&lt; y</code></td>
<td>logical/arithmetic shift left</td>
<td>整体向左移动，并在右边补 0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+=  -=  *=  /=  =  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</td>
<td></td>
<td>运算并赋值的简写形式</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.</td>
<td>dot operator</td>
<td>可以和二元操作符比如 ^, %结合，用来对数组进行运算, ex.  <code>[1,2].^2</code> 的结果为<code>[1, 4]</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:=="><code>==</code></a></td>
<td>equality</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:!="><code>!=</code></a>, <a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:!="><code>≠</code></a></td>
<td>inequality</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:%3C"><code>&lt;</code></a></td>
<td>less than</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:%3C="><code>&lt;=</code></a>, <a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:%3C="><code>≤</code></a></td>
<td>less than or equal to</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:%3E"><code>&gt;</code></a></td>
<td>greater than</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:%3E="><code>&gt;=</code></a>, <a href="https://docs.julialang.org/en/v0.6.4/stdlib/math/#Base.:%3E="><code>≥</code></a></td>
<td>greater than or equal to</td>
<td></td>
</tr>
<tr>
<td>===</td>
<td>对象判等</td>
<td>对于可修改的对象，用内存地址来判等，对于不可修改的对象，通过对象的二进制数据来判等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?:</td>
<td></td>
<td>条件运算符</td>
</tr>
</tbody>
</table>
<h5 id="statements">Statements</h5>
<h6 id="beginend">begin..end</h6>
<p>大部分语言中使用花括号<code>{}</code>来包裹相关联的表达式:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">let</span> z = x + y;
}
</div></code></pre>
<p>而 julia 使用 begin..end 来包裹</p>
<pre class="hljs"><code><div><span class="hljs-keyword">begin</span>
    x = <span class="hljs-number">1</span>
    y = <span class="hljs-number">2</span>
    println(x+y)
<span class="hljs-keyword">end</span>
</div></code></pre>
<h6 id="ifelseifelseend">If..elseif..else..end</h6>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> x &lt; y
    println(<span class="hljs-string">"x is less than y"</span>)
<span class="hljs-keyword">elseif</span> x &gt; y
    println(<span class="hljs-string">"x is greater than y"</span>)
<span class="hljs-keyword">else</span>
    println(<span class="hljs-string">"x is equal to y"</span>)
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>和拥有隐式类型转换的语言不同，这种写法会报类型错误</p>
<pre class="hljs"><code><div>julia&gt; if 1
           return 2;
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context
</div></code></pre>
<h6 id="whileend">while..end</h6>
<p>while 语句。此类通用语法，不再一一列举。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>
    println(<span class="hljs-string">"OK!"</span>)
    <span class="hljs-keyword">break</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<h6 id="for">for</h6>
<pre class="hljs"><code><div>for i = 1:1000
for i in [1,4,0]
for s ∈ [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
</div></code></pre>
<h6 id="trycatchend">try..catch..end</h6>
<pre class="hljs"><code><div><span class="hljs-keyword">try</span>
    throw(<span class="hljs-built_in">DomainError</span>(<span class="hljs-string">"foo"</span>))
<span class="hljs-keyword">catch</span> <span class="hljs-literal">e</span>
    println(<span class="hljs-literal">e</span>)
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>上述代码可以合并成一行, 为了避免 catch 后的变量和之后的表达式混淆，用<code>;</code>来分割它们。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">try</span> throw(<span class="hljs-built_in">BoundsError</span>(<span class="hljs-string">"bar"</span>)) <span class="hljs-keyword">catch</span> <span class="hljs-literal">e</span>; println(<span class="hljs-literal">e</span>) <span class="hljs-keyword">end</span>
</div></code></pre>
<p>当你不需要处理错误的时候，可以省略 catch</p>
<pre class="hljs"><code><div><span class="hljs-keyword">try</span> throw(<span class="hljs-built_in">BoundsError</span>(<span class="hljs-string">"bar"</span>)) <span class="hljs-keyword">end</span>
</div></code></pre>
<h6 id="finally">finally</h6>
<p>和 Java 一样，配合 try..catch 使用</p>
<pre class="hljs"><code><div>f = open(<span class="hljs-string">"file"</span>)
<span class="hljs-keyword">try</span>
    <span class="hljs-comment"># operate on file f</span>
<span class="hljs-keyword">finally</span>
    close(f)
<span class="hljs-keyword">end</span>
</div></code></pre>
<h5 id="expressions">Expressions</h5>
<h6 id="compound-expression">Compound expression</h6>
<p>begin..end 包裹起来的多个表达式可以当作一个表达式来求值</p>
<pre class="hljs"><code><div>v = <span class="hljs-keyword">begin</span>
    x = <span class="hljs-number">1</span>
    y = <span class="hljs-number">2</span>
    x + y
<span class="hljs-keyword">end</span>
println(v)
</div></code></pre>
<p>还有另外两种同样作用的写法:</p>
<pre class="hljs"><code><div>v = (x=<span class="hljs-number">1</span>; y=<span class="hljs-number">2</span>; x+y)
println(v)
</div></code></pre>
<pre class="hljs"><code><div>v = <span class="hljs-keyword">begin</span> x = <span class="hljs-number">1</span>; y = <span class="hljs-number">2</span>; x + y <span class="hljs-keyword">end</span>
println(v)
</div></code></pre>
<h6 id="short-circuit-evaluation">Short-circuit evaluation</h6>
<p>中文名为短路求值，是一种基于逻辑运算符的求值方法, 有点类似于条件表达式</p>
<pre class="hljs"><code><div><span class="hljs-literal">true</span> || <span class="hljs-number">1</span>
</div></code></pre>
<p>上述表达式的值为 1，因为左边的表达式为真值，右边的表达式会被求值并返回/赋值</p>
<pre class="hljs"><code><div><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">2</span>
</div></code></pre>
<p>上述表达式的值为 false，因为左边的值为假值，因此右边的表达式会被忽略。我们来看一个使用此写法的阶乘函数:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> fact(n::<span class="hljs-built_in">Int</span>)
    n &gt;= <span class="hljs-number">0</span> || error(<span class="hljs-string">"n must be non-negative"</span>)
    n == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    n * fact(n-<span class="hljs-number">1</span>)
<span class="hljs-keyword">end</span>
println(fact(<span class="hljs-number">5</span>))
</div></code></pre>
<h6 id="constants">Constants</h6>
<p>Julia 使用<code>const</code>定义常量，将 global 里的常量用 const 标记，有助于 JIT 优化执行速度，局部作用域里的常量可以不用 const 标记，编译器能够自动将其识别出来。</p>
<h5 id="scoping">Scoping</h5>
<p>Julia 的作用域不算特殊，主要有 GLobal，Local，Module 这三种作用域。</p>
<ol>
<li>
<p>每个 module 都有独立的 Global Scope，module 之间需要先引用才能访问, 但是 module A 的变量在 module B 里是只读的</p>
</li>
<li>
<p>语句都会产生一个 local scope, 除了<code>begin..end</code>, <code>if</code>语句。总的来说，<strong>local scope 的所有父级作用域</strong>里的变量在 local scope 是可见的，反之则不可见，这和我们的经验是一致的。</p>
<p>如果需要让 local scope 里的变量在父级作用域里可见，可以强制定义为 global 变量</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:<span class="hljs-number">3</span>
    <span class="hljs-keyword">global</span> x=i
<span class="hljs-keyword">end</span>
x  <span class="hljs-comment"># 3</span>
</div></code></pre>
<p>如果 local scope 和 global scope 都有变量 x，同名了，怎么办？</p>
<p>如果不想用 global 里的 x，可以将 local 里的变量 x 标记为 local, 或者在 local scope 里对 x 重新赋值</p>
<pre class="hljs"><code><div>// case1
x,y=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
<span class="hljs-keyword">function</span> plus()
    x=<span class="hljs-number">1</span>  <span class="hljs-comment"># or local x = 1</span>
    <span class="hljs-keyword">return</span> x+y
<span class="hljs-keyword">end</span>
plus()  <span class="hljs-comment"># 2</span>
x  <span class="hljs-comment"># 0</span>
y  <span class="hljs-comment"># 1</span>
</div></code></pre>
<p>上述代码 x 被重新赋值，新产生了一个局部变量 x，和 global 里的 x 不冲突。</p>
<p>如果想用 global 里的 x 呢？按照总规则，global 的 x 在 local scope 里是天然可见的，直接使用即可。</p>
<pre class="hljs"><code><div>// case2
x,y=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
<span class="hljs-keyword">function</span> plus()
    <span class="hljs-keyword">return</span> x+y
<span class="hljs-keyword">end</span>
plus()  <span class="hljs-comment"># 1</span>
x  <span class="hljs-comment"># 0</span>
y  <span class="hljs-comment"># 1</span>
</div></code></pre>
<p>如果不仅仅是使用，还要修改 global x 呢(当然这么做是不推荐的)？在 case1 当中，x 被修改后，就自动变成 local 的变量了，因此要将 x 指明为 global 再修改，如下:</p>
<pre class="hljs"><code><div>// case3
x,y=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
<span class="hljs-keyword">function</span> plus()
    <span class="hljs-keyword">global</span> x=<span class="hljs-number">100</span>
    <span class="hljs-keyword">return</span> x+y
<span class="hljs-keyword">end</span>
plus()  <span class="hljs-comment"># 101</span>
x  <span class="hljs-comment"># 100</span>
y  <span class="hljs-comment"># 1</span>
</div></code></pre>
<p>你们有没有发现 case1 和 case3 本质上是一样的？都是用关键字显式地指明它所在的作用域。</p>
</li>
</ol>
<h5 id="module">Module</h5>
<p>模块的引入主要是为了引入新的作用域和组织代码结构。定义一个 module 的方式:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> MyModule
<span class="hljs-keyword">export</span> fn <span class="hljs-comment"># 需要暴露的的变量或方法使用 export 来标记</span>
fn() = <span class="hljs-string">"x"</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>导入的方式有两种，<em>using</em>和<em>import</em>，它们的区别在于引入的内容的使用方式，import 会将引入的模块的名称暴露在当前空间，然后通过模块名来使用引入的内容</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> MyModule
MyModule.fn()
</div></code></pre>
<p>using 会将模块导出的所有内容直接暴露在当前空间，使用时不需要模块名</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> MyModule
fn()
</div></code></pre>
<h3 id="%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F">编程范式</h3>
<h5 id="%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</h5>
<p>在 Java 里，我们对一个 Integer 数组使用函数式的方法来操作可以这么写:</p>
<pre class="hljs"><code><div>array.stream()
  .filter(x -&gt; x %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
  .map(x -&gt; x*x)
  .collect(Collectors.toList())
</div></code></pre>
<p>Julia 提供了类似的操作方式:</p>
<pre class="hljs"><code><div>array = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>]
array = filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, array)
array = map(x -&gt; x^<span class="hljs-number">2</span>, array)
println(array) <span class="hljs-comment"># [16, 100]</span>
</div></code></pre>
<p>除了 filter, map 之外，julia 还提供了 reduce, mapreduce 等函数</p>
<pre class="hljs"><code><div>array = mapreduce(x-&gt;x+<span class="hljs-number">10</span>, +, array) <span class="hljs-comment"># (16+10) + (100+10)</span>
println(array) <span class="hljs-comment"># 136</span>
</div></code></pre>
<h5 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</h5>
<p>在 subtype 的章节中，我们介绍了 julia 的类型树，自然 Julia 提供了扩充类型的方式，即抽象类型，定义一个抽象类型:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">abstract type</span> Graph <span class="hljs-keyword">end</span>
</div></code></pre>
<p>它的默认父类是<code>Any</code>, 我们在定义的时候也可以指定父类</p>
<pre class="hljs"><code><div><span class="hljs-keyword">abstract type</span> Graph &lt;: <span class="hljs-built_in">Any</span> <span class="hljs-keyword">end</span>
</div></code></pre>
<p>和 Rust，golang 等语言不同的是，我们并不能为一个 struct 类型定义函数，所以我们看到的仍然是多重派发，而不是其他语言的惯用写法，在理解的时候要暂时抛弃已有的 OOP 概念，不管是 Go，Rust 还是 Julia，传统的 OOP 都被摒弃了。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">struct</span> Circle &lt;: Graph
    radius ::<span class="hljs-built_in">Float64</span>
    x ::<span class="hljs-built_in">Int64</span>
    y ::<span class="hljs-built_in">Int64</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">struct</span> Rec &lt;: Graph
    width ::<span class="hljs-built_in">Float64</span>
    height ::<span class="hljs-built_in">Float64</span>
    x ::<span class="hljs-built_in">Int64</span>
    y ::<span class="hljs-built_in">Int64</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> area(r ::Circle) ::<span class="hljs-built_in">Float64</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">pi</span> * r.radius^<span class="hljs-number">2</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> area(g ::Rec)
    <span class="hljs-keyword">return</span> g.x*g.y
<span class="hljs-keyword">end</span>

println(area(Circle(<span class="hljs-number">1.0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))
println(area(Rec(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))
</div></code></pre>
<p>可能你会觉得上面的代码并不 OOP，我也这么认为，这里举另外一个例子:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">abstract type</span> AbstractGraph &lt;: <span class="hljs-built_in">Any</span> <span class="hljs-keyword">end</span>

<span class="hljs-keyword">struct</span> Graph{T}
    x ::<span class="hljs-built_in">Integer</span>
    y ::<span class="hljs-built_in">Integer</span>
    v ::T
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">struct</span> Circle &lt;: AbstractGraph
    radius ::<span class="hljs-built_in">Float64</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">struct</span> Rec &lt;: AbstractGraph
    width ::<span class="hljs-built_in">Float64</span>
    height ::<span class="hljs-built_in">Float64</span>
<span class="hljs-keyword">end</span>

showLoc(g ::Graph{&lt;:AbstractGraph}) = println(<span class="hljs-string">"("</span>, g.x, <span class="hljs-string">","</span>,g.y ,<span class="hljs-string">")"</span>)
area(g ::Graph{Circle}) = println(<span class="hljs-literal">pi</span> * g.v.radius^<span class="hljs-number">2</span>)
area(g ::Graph{Rec}) = println(g.v.width * g.v.height)

showLoc(Graph{Circle}(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, Circle(<span class="hljs-number">1.0</span>)))
showLoc(Graph{Rec}(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, Rec(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)))

area(Graph{Circle}(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, Circle(<span class="hljs-number">1.0</span>)))
area(Graph{Rec}(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, Rec(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)))
</div></code></pre>
<p>不知道这么写是否让你觉得更 OOP 一点？</p>
<h5 id="%E5%85%83%E7%BC%96%E7%A8%8B">元编程</h5>
<h6 id="%E5%AE%8F">宏</h6>
<p>julia 的宏和 C/C++一样，使用的是文本替代的方式。一个宏将一组参数映射成一个 return 语句，类似于函数的定义。定义一个宏:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">macro</span> say()
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hi"</span>
<span class="hljs-keyword">end</span>

println(<span class="hljs-meta">@say</span>) <span class="hljs-comment"># 调用时使用@加宏名</span>
</div></code></pre>
<h6 id="%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E8%B1%A1">表达式对象</h6>
<p>我们知道，代码里是有表达式的，它们在运行时被编译器求值，同样地我们可以自己创建一个表达式对象，手动来求值。</p>
<pre class="hljs"><code><div>a = <span class="hljs-number">1</span>
b = <span class="hljs-number">1</span>
ex = :($a+$b)
println(eval(ex))
</div></code></pre>
<h6 id="backtick-notation">backtick notation</h6>
<p>julia 可以使用反引号包裹一段 shell, Perl 或 Ruby 代码, 并执行这段代码</p>
<pre class="hljs"><code><div>julia&gt; file = &quot;/etc/passwd&quot;
&quot;/etc/passwd&quot;

julia&gt; readstring(`sort $file`)
“#\n# \n# Note that this file is consulted directly only when the system
...
</div></code></pre>
<h3 id="%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97">科学计算</h3>
<h5 id="multi-dimensional-arrays">Multi-dimensional Arrays</h5>
<p>julia 是一门为科学计算而生的语言，在科学计算里多维数组是一种很常见的数据表达方式。</p>
<p>除了常规的初始化方式之外, julia 提供了更高级的数组构建方式:</p>
<pre class="hljs"><code><div>fn(x) = x^<span class="hljs-number">2</span>
[fn(x) <span class="hljs-keyword">for</span> x=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]
</div></code></pre>
<p>当然，可以直接将函数写在表达式内:</p>
<pre class="hljs"><code><div>[x^<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]
</div></code></pre>
<p>这种方式叫推导(comprehensions), 上面的代码会生成一个一维数组</p>
<pre class="hljs"><code><div>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>]
</div></code></pre>
<p>以此类推，可以生成一个多维数组:</p>
<pre class="hljs"><code><div>[x+y <span class="hljs-keyword">for</span> x=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>, y=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]
</div></code></pre>
<p>当 x,y 的值有联系时:</p>
<pre class="hljs"><code><div>[(i,j) <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>:i]
</div></code></pre>
<p>julia 提供了很多多维数组的操作函数，比如 reshape 函数，将 n*m 的数组转换成 x*y 的数组，且 n*m=x*y.</p>
<pre class="hljs"><code><div>reshape([x+y <span class="hljs-keyword">for</span> x=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>, y=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>], (<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))
</div></code></pre>
<p>上述代码，将 2*10 的数组转换成 4*5 的数组。其他的操作函数可以查看文档。</p>
<h5 id="linear-algebra">Linear algebra</h5>
<p>julia 内置了很多线性代数的算法，比如计算一个 n*n 矩阵的迹数</p>
<pre class="hljs"><code><div>julia&gt; A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia&gt; trace(A)
3
</div></code></pre>
<p>这里不再一一列举，感兴趣的可以查看<a href="https://docs.julialang.org/en/v0.6.4/manual/linear-algebra/">文档</a>.</p>
<h3 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h3>
<ol>
<li><a href="https://docs.julialang.org/en/v0.6.2/manual/style-guide/#Style-Guide-1">Style Guide</a></li>
<li><a href="https://discourse.julialang.org/t/is-julia-a-strongly-checked-language/12990/3?u=songtianyi">is-julia-strongly-checked?</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3">类型双关</a></li>
<li><a href="https://discourse.julialang.org/t/how-to-explain-these-two-statements/13393">How to explain these two statements?</a></li>
<li><a href="https://raw.githubusercontent.com/wiki/jiahao/parallel-prefix/main.pdf">《The many facets of operator polymorphism in Julia》</a></li>
</ol>
<h3 id=""></h3>

</body>
</html>
