<!DOCTYPE html>
<html>
<head>
<title>M-rust-macro.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="rust-%E5%AE%8F">Rust 宏</h1>
<h2 id="%E5%89%8D%E8%A8%80">前言</h2>
<p>18 年系统学习编程语言理论的时候快速学过 Rust，两年过去了还没实际使用过它做开发，最近在使用 TDengine 的时候，发现 TDengine 的 Go binding 没有实现订阅的接口，C++ 又没多大兴趣，于是在前人的基础上把 TDengine 的 Rust binding 写了一遍，然后使用 Rust 写了 业务逻辑的 API 接口。在做错误处理的时候，认识到了 Rust 宏的强大，所以想着重新学下 Rust 宏，做个笔记。</p>
<h2 id="c-macro">C Macro</h2>
<p>宏的概念我们在刚学计算的时候就接触过，C 语言里的 <code>#define xxx</code> 就是宏。</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH_OF_ARRAY 5 <span class="hljs-comment">// this is a define macro</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> numbers[LENGTH_OF_ARRAY]; <span class="hljs-comment">// initializes the array</span>

    <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// incrementing variable</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LENGTH_OF_ARRAY; i++) {
        numbers[i] = i;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>但是老师或者书本里应该会告诉我们，尽量不要使用宏。复杂的宏定义会降低代码的可读性，而且容易写出意想不到的 bug，举个例子：</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEN 5 + 5</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, <span class="hljs-number">5</span> * TEN);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>只有能驾驭好它的程序员才能随心使用它。
C 语言的宏不仅是简单的字符串替换，它还支持参数:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD(X, Y) (X + Y)</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> ADD(a, b);
}
<span class="hljs-comment">// translate to</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> (a + b);
}
</div></code></pre>
<h2 id="rust-declarative-macros">Rust declarative macros</h2>
<p>Rust 宏相对 C 来说要复杂很多，自然也强大很多。我们最先接触到的宏应该是 <code>println!</code> . 它的定义是这样的:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">macro_rules!</span> println {
    () =&gt; ($crate::<span class="hljs-built_in">print!</span>(<span class="hljs-string">"\n"</span>));
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    })
}
</div></code></pre>
<p>很难看懂对不对？
<code>macro_rules!</code> 相当于 <code>#define</code> , 用来标记这是一段宏定义， <code>println</code> 是宏的名称，括号里的内容是 <code>println</code> 这个宏具体的定义。</p>
<p><code>()</code> 是在我们忘记写函数的返回语句的时候会看到的提示，如:</p>
<pre class="hljs"><code><div>
 --&gt; println.rs:3:5
  |
2 | fn return() -&gt; i32 {
  |                --- expected `i32` because of return type
3 |     ()
  |     ^^ expected `i32`, found `()`

</div></code></pre>
<p>我们可以把 <code>()</code> 简单看做是 empty。
那么下面这段代码就比较容易理解了</p>
<pre class="hljs"><code><div>() =&gt; ($crate::<span class="hljs-built_in">print!</span>(<span class="hljs-string">"\n"</span>))
</div></code></pre>
<p>我们使用 <code>println!</code> 宏的时候不传入参，就会匹配到这条语句，这条语句只会打印换行。
所以 <code>=&gt;</code> 之前的 <code>()</code> 内的内容就是匹配模式，称为 <code>Matcher</code> , <code>=&gt;</code> 之后的内容就是匹配到入参之后，待展开的逻辑，称为 <code>Transcriber</code> , 编译器利用入参和 <code>Transcriber</code> 来生成展开后的 Rust 代码。</p>
<img src="https://songtianyi-blog.oss-cn-shenzhen.aliyuncs.com/matcher-transcriber.png" alt="matcher-transcriber" style="width:800px; height:500px"/>
<p><code>Matcher</code> 里的内容又可以分为两部分，name 和 designator:</p>
<img src="https://songtianyi-blog.oss-cn-shenzhen.aliyuncs.com/matcher.png" alt="matcher-transcriber" style="width:800px; height:500px"/>
<p>name 相当于变量名，用 <code>$</code> 符号标记，designator 可以理解为是预定义的正则表达式, 书写的时候直接用简写名称代替，有以下几种:</p>
<ul>
<li>item: an item, such as a function, a struct, a module, etc.</li>
<li>block: a block (i.e. a block of statements and/or an expression, surrounded by braces)</li>
<li>stmt: a statement</li>
<li>pat: a pattern</li>
<li>expr: an expression</li>
<li>ty: a type</li>
<li>ident: an identifier</li>
<li>path: a path (e.g. foo, ::std::mem::replace, transmute::&lt;_, int&gt;, ...)</li>
<li>meta: a meta item; the things that go inside #[...] and #![...] attributes</li>
<li>tt: a single token tree</li>
</ul>
<p>以 <code>map!</code> 宏为例来看下 HashMap 的初始化方式， 如下:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::collections::HashMap;
<span class="hljs-built_in">macro_rules!</span> map {
    ($($key:expr =&gt; $value:expr), *) =&gt; {
        {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hm = HashMap::new();
            $( hm.insert($key, $value); )*
            hm
		}
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:#?}"</span>, map!(
	    <span class="hljs-string">"a"</span> =&gt; <span class="hljs-string">"b"</span>,
	    <span class="hljs-string">"c"</span> =&gt; <span class="hljs-string">"d"</span>
	));
}
</div></code></pre>
<p>它所使用的 <code>Matcher</code> 是 <code>$($key:expr =&gt; $value:expr), *)</code> , 看起来有些复杂</p>
<p><code>=&gt;</code> 不能被替换成其他符号，如 <code>:</code> , <code>-&gt;</code> 等, 没有特殊意义，就是用来匹配文本中的 <code>=&gt;</code> 符号, <code>$key:expr =&gt; $value:expr</code> 可以看待为 <code>expr =&gt; expr</code> , 相当于正则。之后，将这个正则包裹起来，加上 <code>*</code> 来表示这个正则可以被匹配多次，相当于 <code>(expr =&gt; expr)*</code></p>
<img src="https://songtianyi-blog.oss-cn-shenzhen.aliyuncs.com/repeat.png" alt="matcher-transcriber" style="width:800px; height:500px"/>
<p>下面是一个更复杂的实际案例，用来简化 Field 的取值方法的编写:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Field</span></span> {
    tinyInt(<span class="hljs-built_in">i8</span>),
    smallInt(<span class="hljs-built_in">i16</span>),
    normalInt(<span class="hljs-built_in">i32</span>),
    bigInt(<span class="hljs-built_in">i64</span>),
    float(<span class="hljs-built_in">f32</span>),
    double(<span class="hljs-built_in">f64</span>),
    string(<span class="hljs-built_in">String</span>),
    boolType(<span class="hljs-built_in">bool</span>),
}

<span class="hljs-built_in">macro_rules!</span> impl_as_fields {
    ($<span class="hljs-function"><span class="hljs-keyword">fn</span>:<span class="hljs-title">ident</span>, $<span class="hljs-title">pattern</span>:<span class="hljs-title">pat</span> =&gt; $<span class="hljs-title">v</span>:<span class="hljs-title">expr</span>, $<span class="hljs-title">type</span>:<span class="hljs-title">ty</span>) =&gt; {
        <span class="hljs-title">pub</span> <span class="hljs-title">fn</span> $<span class="hljs-title">fn</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; $<span class="hljs-class"><span class="hljs-keyword">type</span> {
            <span class="hljs-title">match</span></span> *<span class="hljs-keyword">self</span> {
                $pattern =&gt; $v,
                _ =&gt; {
                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"unexpected $type value {}"</span>, <span class="hljs-keyword">self</span>);
                    <span class="hljs-built_in">Default</span>::default()
                }
            }
        }
    };
}

<span class="hljs-keyword">impl</span> Field {
    impl_as_fields!(as_i8, Field::tinyInt(v) =&gt; v, <span class="hljs-built_in">i8</span>);
    impl_as_fields!(as_i16, Field::smallInt(v) =&gt; v, <span class="hljs-built_in">i16</span>);
    impl_as_fields!(as_i32, Field::normalInt(v) =&gt; v, <span class="hljs-built_in">i32</span>);
    impl_as_fields!(as_i64, Field::bigInt(v) =&gt; v, <span class="hljs-built_in">i64</span>);
    impl_as_fields!(as_f32, Field::float(v) =&gt; v, <span class="hljs-built_in">f32</span>);
    impl_as_fields!(as_f64, Field::double(v) =&gt; v, <span class="hljs-built_in">f64</span>);
    impl_as_fields!(as_bool, Field::boolType(v) =&gt; v, <span class="hljs-built_in">bool</span>);

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_string</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-keyword">match</span> &amp;*<span class="hljs-keyword">self</span> {
            Field::string(v) =&gt; v.to_string(),
            _ =&gt; {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"unexpected string value {}"</span>, <span class="hljs-keyword">self</span>);
                <span class="hljs-string">""</span>.to_string()
            }
        }
    }
}
</div></code></pre>
<p>上述的宏 <code>impl_as_fields</code> 会根据入参数展开成返回不同类型的函数定义(类似 as_string), 用到了多个 designator.</p>
<h2 id="rust-procedural-macros">Rust procedural macros</h2>
<p>上一节所讲的 rust macro 属于 <code>declarative macro</code> , rust 还有一类宏, 叫 <code>procedural macro</code> .</p>
<h4 id="derive">#[derive]</h4>
<p>一种是我们经常见到的 <code>derive</code> 属性, 需要打印一个结构体而又不想自己实现的时候，可以在结构体上运用 <code>#[derive(Debug)]</code> 来帮我们实现 <code>Debug</code> Trait.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span> {
    name: <span class="hljs-built_in">String</span>,
    age: <span class="hljs-built_in">i32</span>,
}

<span class="hljs-keyword">impl</span> Student {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">Self</span> {
            name: <span class="hljs-string">""</span>.to_string(),
            age: -<span class="hljs-number">1</span>,
        };
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, Student::new());
}
</div></code></pre>
<p>如果去除 <code>derive(Debug)</code> 则会遇到以下常见编译错误:</p>
<blockquote>
<p>--&gt; derive.rs:17:22</p>
<p>|</p>
<p>17 |     println!(&quot;{:?}&quot;, Student::new());</p>
<p>|                      ^^^^^^^^^^^^^^ <code>Student</code> cannot be formatted using <code>{:?}</code></p>
</blockquote>
<blockquote>
<p>|</p>
<p>= help: the trait <code>Debug</code> is not implemented for <code>Student</code></p>
</blockquote>
<blockquote>
<p>= note: add <code>#[derive(Debug)]</code> or manually implement <code>Debug</code></p>
</blockquote>
<blockquote>
<p>= note: required by <code>std::fmt::Debug::fmt</code></p>
</blockquote>
<blockquote></blockquote>
<p><code>derive(Debug)</code> '神奇地'帮我们实现了一个自定义结构体的 <code>Debug</code> trait. 这实际上是编译器在编译的时候帮我们生成了实现代码，而不是在运行时，rust 是不支持反射的。</p>
<p>我们可以自己实现一个 <code>derive</code> 宏.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#</span><span class="bash"> 创建一个 status crate</span>
cargo new status  --lib
</div></code></pre>
<p>在 <code>status/src/lib.rs</code> 里定义 <code>Status</code> trait, 其功能为打印结构体的状态。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Status</span></span> {
    <span class="hljs-comment">/// Return the status of `self`</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">status</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span>;
}
</div></code></pre>
<p>接着实现 <code>Status</code> macro.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#</span><span class="bash"> 创建一个 status_derive crate</span>
cargo new status_derive  --lib
</div></code></pre>
<blockquote>
<p><code>declarative macro</code> 类似于字符串替换，只不过加了匹配规则和变量，让我们可以写更复杂的逻辑，而 <code>procedural macro</code> 提供了源码的 token 输入，即 <code>TokenStream</code> , 并提供了语法树工具，让我们有能力直接处理源码。</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">// status_derive/src/lib.rs</span>
<span class="hljs-keyword">use</span> proc_macro2::TokenStream;
<span class="hljs-keyword">use</span> quote::{quote, quote_spanned};
<span class="hljs-keyword">use</span> syn::spanned::Spanned;
<span class="hljs-keyword">use</span> syn::{parse_macro_input, parse_quote, Data, DeriveInput, Fields, GenericParam, Generics, Index};

<span class="hljs-meta">#[proc_macro_derive(Status)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">derive_status</span></span>(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {
    <span class="hljs-comment">// 暂时留空</span>
}
</div></code></pre>
<p>修改 <code>status/Cargo.toml</code> , 添加 status_derive crate 依赖.</p>
<pre class="hljs"><code><div><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">status_derive</span> = { path = <span class="hljs-string">"../status_derive"</span> }
</div></code></pre>
<p>创建一个测试程序</p>
<pre class="hljs"><code><div>cargo new status_derive_test  --bin
</div></code></pre>
<p>并添加依赖:</p>
<pre class="hljs"><code><div><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">status</span> = { path = <span class="hljs-string">"../status"</span> }
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// status_derive_test/src/lib.rs</span>
<span class="hljs-keyword">use</span> status::Status;

<span class="hljs-meta">#[derive(Status)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span> {
    name: <span class="hljs-built_in">String</span>,
    age: <span class="hljs-built_in">i32</span>,
    status: <span class="hljs-built_in">String</span>,
}

<span class="hljs-keyword">impl</span> Student {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">Self</span> {
            name: <span class="hljs-string">""</span>.to_string(),
            age: -<span class="hljs-number">1</span>,
            status: <span class="hljs-string">"OK"</span>,
        };
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, Student::new().status());
}
</div></code></pre>
<p>目前代码还未完成，编译会失败，我们从目标出发，将 <code>derive_status</code> 函数填充完整。
我们的目标是生成一个函数， 如下:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">impl</span> Status <span class="hljs-keyword">for</span> Student {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">status</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}'s status is {}"</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.status)
    }
}
</div></code></pre>
<p>先考虑的简单点，直接用 <code>quote!</code> 将字符串转成 <code>TokenStram</code> 返回</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> c = quote!(
    <span class="hljs-keyword">impl</span> Status <span class="hljs-keyword">for</span> Student {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">status</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
            <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}'s status is {}"</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.status)
        }
    }
)
proc_macro::TokenStream::from(c)
</div></code></pre>
<p>这样是能成功的，但是不够通用，Student 被 hardcode 了，换个结构体名字就不适用了。这个时候要利用 <code>inupt</code> 参数:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 将输入做些处理以便使用</span>
<span class="hljs-keyword">let</span> input = parse_macro_input!(input <span class="hljs-keyword">as</span> DeriveInput);
<span class="hljs-comment">// 将结构体的名称取出来, 在 quote! 中以变量的形式引用</span>
<span class="hljs-keyword">let</span> name = input.ident;
<span class="hljs-keyword">let</span> c = quote!(
    <span class="hljs-keyword">impl</span> Status <span class="hljs-keyword">for</span> #name {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">status</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
            <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}'s status is {}"</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.status)
        }
    }
)
proc_macro::TokenStream::from(c)
</div></code></pre>
<p>如此，我们完成了一个名为 <code>Status</code> 的 <code>derive</code> macro, 可以运用在任意带有 <code>status</code> 字段的结构体上。</p>
<blockquote>
<p>input 的结构应该可以打印出来, 但我还没找到打印方法。知晓结构之后我们就能完成更复杂的代码生成逻辑</p>
</blockquote>
<h4 id="attribute-like-macros">Attribute-like macros</h4>
<p>和 <code>derive</code> macro 是类似的，可以理解为是将 <code>derive</code> 换成了更一般的名字， <code>derive</code> macro 是 <code>attribute-like macro</code> 的一种特例。
<code>derive</code> macro 只能用于 <code>struct</code> 和 <code>enum</code> , 而 <code>attribute-like macro</code> 可以运用在其它的对象上，比如函数。如果你用过 rust 的 web 框架，可能会见到下面的代码片段:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#[route(GET, <span class="hljs-meta-string">"/"</span>)]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>() {
}
</div></code></pre>
<p><code>route</code> 宏的实现和 <code>derive</code> 有些区别:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#[proc_macro_attribute]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">route</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
}
</div></code></pre>
<ul>
<li>使用的 <code>attribute</code> 是 <code>proc_macro_attribute</code></li>
<li>它接受两个参数，<code>attr</code> 是 <code>GET, &quot;/&quot;</code> 这部分，<code>item</code> 存的是对应的函数，即:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>() {}
</div></code></pre>
<p>其余的部分和 <code>derive</code> macro 的实现是一致的。</p>
<h4 id="function-like-macros">Function-like macros</h4>
<p>顾名思义， <code>Function-like</code> macro 在使用上比较像函数，或者说像 <code>declarative</code> macro, 但相对函数和 <code>macro_rules!</code> 来说， <code>Function-like</code> macro 更加灵活，参数可以不固定。比较典型的例子是 <code>sql!</code> .</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> sql = sql!(SELECT * FROM posts WHERE id=<span class="hljs-number">1</span>);
</div></code></pre>
<p>它的实现方式和前两种 <code>procedural</code> macro 是类似的:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#[proc_macro]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sql</span></span>(input: TokenStream) -&gt; TokenStream {
}
</div></code></pre>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros</a></li>
<li><a href="https://github.com/dtolnay/syn/tree/master/examples/heapsize">HeapSize derive example</a></li>
</ul>

</body>
</html>
