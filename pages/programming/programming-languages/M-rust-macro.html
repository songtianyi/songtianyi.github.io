<!DOCTYPE html>
<html>
<head>
<title>M-rust-macro.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* a11y-light theme */
/* Based on the Tomorrow Night Eighties theme: https://github.com/isagalaev/highlight.js/blob/master/src/styles/tomorrow-night-eighties.css */
/* @author: ericwbailey */

/* Comment */
.hljs-comment,
.hljs-quote {
  color: #696969;
}

/* Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #d91e18;
}

/* Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #aa5d00;
}

/* Yellow */
.hljs-attribute {
  color: #aa5d00;
}

/* Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #008000;
}

/* Blue */
.hljs-title,
.hljs-section {
  color: #007faa;
}

/* Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #7928a1;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #fefefe;
  color: #545454;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

@media screen and (-ms-high-contrast: active) {
  .hljs-addition,
  .hljs-attribute,
  .hljs-built_in,
  .hljs-builtin-name,
  .hljs-bullet,
  .hljs-comment,
  .hljs-link,
  .hljs-literal,
  .hljs-meta,
  .hljs-number,
  .hljs-params,
  .hljs-string,
  .hljs-symbol,
  .hljs-type,
  .hljs-quote {
        color: highlight;
    }

    .hljs-keyword,
    .hljs-selector-tag {
        font-weight: bold;
    }
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="rust-%E5%AE%8F">Rust 宏</h1>
<h2 id="%E5%89%8D%E8%A8%80">前言</h2>
<p>18年系统学习编程语言理论的时候，快速学过 Rust，两年过去了还没实际使用过它做开发，最近在使用 TDengine 的时候，发现 TDengine 的 Go binding 没有实现订阅的接口，C++ 又没多大兴趣，于是在前人的基础上把 TDengine 的 Rust binding 写了一遍，然后使用 Rust 写了 业务逻辑的 API 接口。在做错误处理的时候，认识到了 Rust 宏的强大，所以想着重新学下 Rust 宏，做个笔记。</p>
<h2 id="c-macro">C Macro</h2>
<p>宏的概念我们在刚学计算的时候就接触过，C 语言里的 <code>#define xxx</code> 就是宏。</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH_OF_ARRAY 5 <span class="hljs-comment">// this is a define macro</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> numbers[LENGTH_OF_ARRAY]; <span class="hljs-comment">// initializes the array</span>

    <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// incrementing variable</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LENGTH_OF_ARRAY; i++) {
        numbers[i] = i;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>但是老师或者书本里应该会告诉我们，尽量不要使用宏。复杂的宏定义会降低代码的可读性，而且容易写出意想不到的 bug，举个例子：</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEN 5 + 5</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, <span class="hljs-number">5</span> * TEN);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>只有能驾驭好它的程序员才能随心使用它。<br>
C 语言的宏不仅是简单的字符串替换，它还支持参数:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD(X, Y) (X + Y)</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> ADD(a, b);
}
<span class="hljs-comment">// translate to</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> (a + b);
}
</div></code></pre>
<h2 id="rust-macro">Rust macro</h2>
<p>Rust 宏相对 C 来说要复杂很多，自然也强大很多。我们最先接触到的宏应该是 <code>println!</code> . 它的定义是这样的:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">macro_rules!</span> println {
    () =&gt; ($crate::<span class="hljs-built_in">print!</span>(<span class="hljs-string">"\n"</span>));
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    })
}
</div></code></pre>
<p>很难看懂对不对？<br>
<code>macro_rules!</code> 相当于 <code>#define</code> , 用来标记这是一段宏定义， <code>println</code> 是宏的名称，括号里的内容是 <code>println</code> 这个宏具体的定义。</p>
<p><code>()</code> 在我们忘记写函数的返回语句的时候会看到的提示:</p>
<pre class="hljs"><code><div>
 --&gt; println.rs:3:5
  |
2 | fn return() -&gt; i32 {
  |                --- expected `i32` because of return type
3 |     ()
  |     ^^ expected `i32`, found `()`

</div></code></pre>
<p>我们可以把 <code>()</code> 简单看做是 empty。<br>
那么下面这段代码就比较容易理解了</p>
<pre class="hljs"><code><div>() =&gt; ($crate::<span class="hljs-built_in">print!</span>(<span class="hljs-string">"\n"</span>))
</div></code></pre>
<p>我们使用 <code>println!</code> 宏的时候不写参数，就会匹配到这条语句，这条语句只会打印换行。<br>
所以 <code>=&gt;</code> 之前的 <code>()</code> 内的内容就是匹配模式，称为 <code>Matcher</code> , <code>=&gt;</code> 之后的内容就是匹配到入参之后，待展开的逻辑，称为 <code>Transcriber</code> , 编译器利用入参和 <code>Transcriber</code> 来生成展开后的 Rust 代码。</p>
<img src="https://songtianyi-blog.oss-cn-shenzhen.aliyuncs.com/matcher-transcriber.png" alt="matcher-transcriber" style="width:800px; height:500px"/>
<p><code>Matcher</code> 里的内容又可以分为两部分，name 和 designator:</p>
<img src="https://songtianyi-blog.oss-cn-shenzhen.aliyuncs.com/matcher.png" alt="matcher-transcriber" style="width:800px; height:500px"/>
<p>name 相当于变量名，用 <code>$</code> 符号标记，designator 可以理解为是预定义的正则表达式, 书写的时候直接用简写名称代替，有以下几种:</p>
<ul>
<li>item: an item, such as a function, a struct, a module, etc.</li>
<li>block: a block (i.e. a block of statements and/or an expression, surrounded by braces)</li>
<li>stmt: a statement</li>
<li>pat: a pattern</li>
<li>expr: an expression</li>
<li>ty: a type</li>
<li>ident: an identifier</li>
<li>path: a path (e.g. foo, ::std::mem::replace, transmute::&lt;_, int&gt;, ...)</li>
<li>meta: a meta item; the things that go inside #[...] and #![...] attributes</li>
<li>tt: a single token tree</li>
</ul>
<p>以 <code>map!</code> 宏为例来看下 HashMap 的初始化方式， 如下:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::collections::HashMap;
<span class="hljs-built_in">macro_rules!</span> map {
    ($($key:expr =&gt; $value:expr), *) =&gt; {
        {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hm = HashMap::new();
            $( hm.insert($key, $value); )*
            hm
		}
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:#?}"</span>, map!(
	    <span class="hljs-string">"a"</span> =&gt; <span class="hljs-string">"b"</span>,
	    <span class="hljs-string">"c"</span> =&gt; <span class="hljs-string">"d"</span>
	));
}
</div></code></pre>
<p>它所使用的 <code>Matcher</code> 是 <code>$($key:expr =&gt; $value:expr), *)</code> , 看起来有些复杂</p>
<p><code>=&gt;</code> 不能被替换成其他符号，如 <code>:</code> , <code>-&gt;</code> 等, 没有特殊意义，就是用来匹配文本中的 <code>=&gt;</code> 符号, <code>$key:expr =&gt; $value:expr</code> 可以看待为 <code>expr =&gt; expr</code> , 相当于正则。之后，将这个正则包裹起来，加上 <code>*</code> 来表示这个正则可以被匹配多次，相当于 <code>(expr =&gt; expr)*</code></p>
<img src="https://songtianyi-blog.oss-cn-shenzhen.aliyuncs.com/repeat.png" alt="matcher-transcriber" style="width:800px; height:500px"/>
<p>下面是一个更复杂的实际案例，用来简化 Field 的取值方法的编写:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Field</span></span> {
    tinyInt(<span class="hljs-built_in">i8</span>),
    smallInt(<span class="hljs-built_in">i16</span>),
    normalInt(<span class="hljs-built_in">i32</span>),
    bigInt(<span class="hljs-built_in">i64</span>),
    float(<span class="hljs-built_in">f32</span>),
    double(<span class="hljs-built_in">f64</span>),
    string(<span class="hljs-built_in">String</span>),
    boolType(<span class="hljs-built_in">bool</span>),
}

<span class="hljs-built_in">macro_rules!</span> impl_as_fields {
    ($<span class="hljs-function"><span class="hljs-keyword">fn</span>:<span class="hljs-title">ident</span>, $<span class="hljs-title">pattern</span>:<span class="hljs-title">pat</span> =&gt; $<span class="hljs-title">v</span>:<span class="hljs-title">expr</span>, $<span class="hljs-title">type</span>:<span class="hljs-title">ty</span>) =&gt; {
        <span class="hljs-title">pub</span> <span class="hljs-title">fn</span> $<span class="hljs-title">fn</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; $<span class="hljs-class"><span class="hljs-keyword">type</span> {
            <span class="hljs-title">match</span></span> *<span class="hljs-keyword">self</span> {
                $pattern =&gt; $v,
                _ =&gt; {
                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"unexpected $type value {}"</span>, <span class="hljs-keyword">self</span>);
                    <span class="hljs-built_in">Default</span>::default()
                }
            }
        }
    };
}

<span class="hljs-keyword">impl</span> Field {
    impl_as_fields!(as_i8, Field::tinyInt(v) =&gt; v, <span class="hljs-built_in">i8</span>);
    impl_as_fields!(as_i16, Field::smallInt(v) =&gt; v, <span class="hljs-built_in">i16</span>);
    impl_as_fields!(as_i32, Field::normalInt(v) =&gt; v, <span class="hljs-built_in">i32</span>);
    impl_as_fields!(as_i64, Field::bigInt(v) =&gt; v, <span class="hljs-built_in">i64</span>);
    impl_as_fields!(as_f32, Field::float(v) =&gt; v, <span class="hljs-built_in">f32</span>);
    impl_as_fields!(as_f64, Field::double(v) =&gt; v, <span class="hljs-built_in">f64</span>);
    impl_as_fields!(as_bool, Field::boolType(v) =&gt; v, <span class="hljs-built_in">bool</span>);

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_string</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-keyword">match</span> &amp;*<span class="hljs-keyword">self</span> {
            Field::string(v) =&gt; v.to_string(),
            _ =&gt; {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"unexpected string value {}"</span>, <span class="hljs-keyword">self</span>);
                <span class="hljs-string">""</span>.to_string()
            }
        }
    }
}
</div></code></pre>
<p>上述的宏 <code>impl_as_fields</code> 会根据入参数展开成返回不同类型的函数定义(类似 as_string), 用到了多个 designator.</p>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2>

</body>
</html>
