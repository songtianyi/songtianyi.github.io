<!DOCTYPE html>
<html>
<head>
<title>go2-design-draft-introduction.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="go2-%E8%AE%BE%E8%AE%A1%E8%8D%89%E6%A1%88%E4%BB%8B%E7%BB%8D">go2 设计草案介绍</h1>
<p>作者: <a href="http://songtianyi.info">songtianyi</a> 2018-08-29</p>
<h3 id="%E5%89%8D%E8%A8%80">前言</h3>
<p>Go，毫无疑问已经成为主流服务端开发语言之一，但它的类型特性却少的可怜，仅支持<a href="mds/techinques/how-to-choose-your-programming-language.md">structural subtyping</a>。在 TIOBE 排名前二十的语言中，不管是上古语言 Java, 还是 2010 年之后出现的新语言 Rust/Julia 等，都支持至少三种类型特性，对此社区抱怨很多，另外还有它的错误处理方式，以及在 Go1.11 版本才解决的依赖管理等问题。在最近的 GopherCon2018 上，官方放出了解决这些问题的草案(draft)，这些内容还没有成为正式的提案(proposal), 只是先发出来供大家讨论，最终会形成正式提案并被逐步引入到后续的版本中。此次放出的草案，集中讨论了三个问题，泛型/错误处理/错误值。</p>
<h3 id="%E6%B3%9B%E5%9E%8B">泛型</h3>
<p>泛型是复用逻辑的一个有效手段，在 2016 和 2017 年的 Go 语言调查中，泛型都列在最迫切的需求之首，在 Go1.0 release 之后 Go team 就已经开始探索如何引入泛型，但同时要保持 Go 的简洁性(开发者喜爱 Go 的主要原因之一)，之前的几种实现方式都存在严重的问题，被废弃掉了，所以进展并不算快，导致部分人误解为 Go team 并不打算引入泛型。现在，最新的草案经过半年的讨论和优化已经确认可行(could work)，我们期待已久的泛型几乎是板上钉钉的事情了，那么 Go 的泛型大概长什么样？</p>
<p>在没有泛型的情况下，通过<code>interface{}</code>是可以解决部分问题的，比如<a href="https://golang.org/src/container/ring/ring.go"><code>ring</code></a>的实现，但这种方法只适合用在数据容器里, 且需要做类型转换。当我们需要实现一个通用函数时，就做不到了，例如实现一个函数，其返回传入的 map 的 key:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Keys</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>{}]<span class="hljs-keyword">interface</span>{})</span> []<span class="hljs-title">interface</span></span>{} {
	keys := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>{}, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> m {
		keys = <span class="hljs-built_in">append</span>(keys, k)
	}
	<span class="hljs-keyword">return</span> keys
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)
	m[<span class="hljs-string">"demo"</span>] = <span class="hljs-string">"data"</span>
	fmt.Println(Keys(m))
}
</div></code></pre>
<p>这样写连编译都通过不了，因为类型不匹配。那么参考其他支持泛型的语言的语法，可以这样写:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Keys</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span> []<span class="hljs-title">K</span></span> {
	keys := <span class="hljs-built_in">make</span>([]K, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> m {
		keys = <span class="hljs-built_in">append</span>(keys, k)
	}
	<span class="hljs-keyword">return</span> keys
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)
	m[<span class="hljs-string">"demo"</span>] = <span class="hljs-string">"data"</span>
	fmt.Println(Keys(m))
}
</div></code></pre>
<p>但是这种写法是有缺陷的，假设 append 函数并不支持 string 类型，就可能会出现编译错误。我们可以看下其他语言的做法:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// rust</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_g</span></span>&lt;T: Graph&gt;(g : T) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"graph area {}"</span>, g.area());
}
</div></code></pre>
<p>Rust 在声明 T 的时候，限定了入参的类型，即入参 <em>g</em> 必须是实现了 Graph 的类型。和<a href="mds/techniques/getting-started-with-rust-in-1-hour.md">Rust</a>的 nominal subtyping 不同，Go 属于 structural subtyping，没有显式的类型关系声明，因此不能使用此种方式。Go 在草案中引入了<code>contract</code>来解决这个问题，语法类似于函数, 写法更复杂，但拥有和 Rust trait 相媲美的表达能力:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// comparable contract</span>
contract Equal(t T) {
	t == t
}
<span class="hljs-comment">// addable contract</span>
contract Addable(t T) {
	t + t
}
<span class="hljs-comment">// 约束类型 T 必须拥有函数 func String() string</span>
contract stringer(x T) {
	<span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span> = x.String()
}
</div></code></pre>
<p>上述代码分别约束了 T 必须是可比较的(comparable)，必须是能做加法运算(addable)的。使用方式很简单, 定义函数的时候加上<code>contract</code>即可:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">type</span> T Addable(T)</span>)<span class="hljs-params">(x []T)</span> <span class="hljs-title">T</span></span> {
	<span class="hljs-keyword">var</span> total T
	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> x {
		total += v
	}
	<span class="hljs-keyword">return</span> total
}

<span class="hljs-keyword">var</span> x []<span class="hljs-keyword">int</span>
total := Sum(<span class="hljs-keyword">int</span>)(x)
</div></code></pre>
<p>上述代码约束了入参 <em>x</em> 的类型 T 必须是可以做加法运算的类型。</p>
<blockquote>
<p>可能大家会有跟我一样的疑问，为什么是(type T Addable) , 而不是 &lt;T&gt;, 为什么不用惯用的尖括号？</p>
<p>官方给出的解释是 <a href="https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md#why-not-use-like-c_and-java"><em>keep the Go parser simple</em></a></p>
</blockquote>
<p>得益于类型推断，在调用 Sum 时可以简写成:</p>
<pre class="hljs"><code><div>total := Sum(x)
</div></code></pre>
<p>contract 在使用时，如果参数是一一对应的(可推断), 也可以省略它的参数:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Addable(T) --&gt; Addable</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">type</span> T Addable)</span><span class="hljs-params">(x []T)</span> <span class="hljs-title">T</span></span> {
	<span class="hljs-keyword">var</span> total T
	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> x {
		total += v
	}
	<span class="hljs-keyword">return</span> total
}
</div></code></pre>
<p>不可推断时就需要指明该 contract 是用来约束谁的:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Equal 用来约束类型 K，而不是类型 V</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Keys</span><span class="hljs-params">(<span class="hljs-keyword">type</span> K, V Equal(K)</span>)<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span> []<span class="hljs-title">K</span></span> {
	...
}
</div></code></pre>
<p>当然，下面的写法也可以推断，最终的形式就看社区的反馈和 Go team 的抉择了:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Keys</span><span class="hljs-params">(<span class="hljs-keyword">type</span> K Equal, V)</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span> []<span class="hljs-title">K</span></span> {
	...
}
</div></code></pre>
<p>关于实现方面的内容，这里不再讨论，留给高手吧。官方开通了反馈渠道，可以去<a href="https://github.com/golang/go/wiki/Go2GenericsFeedback">提意见</a>，对于我来说，唯一不满意的地方是显式的<code>type</code>关键字, 可能是为了方便和后边的函数参数相区分吧。</p>
<h3 id="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</h3>
<p>健壮的程序需要大量的错误处理逻辑，在极端情况下，错误处理逻辑甚至比业务逻辑还要多，那么更简洁有效的错误处理语法是我们所追求的。</p>
<p>先看下目前 Go 的错误处理方式，一个拷贝文件的例子:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CopyFile</span><span class="hljs-params">(src, dst <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
	r, err := os.Open(src)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"copy %s %s: %v"</span>, src, dst, err)
	}
	<span class="hljs-keyword">defer</span> r.Close()

	w, err := os.Create(dst)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"copy %s %s: %v"</span>, src, dst, err)
	}

	<span class="hljs-keyword">if</span> _, err := io.Copy(w, r); err != <span class="hljs-literal">nil</span> {
		w.Close()
		os.Remove(dst)
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"copy %s %s: %v"</span>, src, dst, err)
	}

	<span class="hljs-keyword">if</span> err := w.Close(); err != <span class="hljs-literal">nil</span> {
		os.Remove(dst)
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"copy %s %s: %v"</span>, src, dst, err)
	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</div></code></pre>
<p>上述代码中，错误处理的代码占了总代码量的近 50%！</p>
<p>Go 的<code>assignment-and-if-statement </code>错误处理语句是罪魁祸首，草案引入了<code>check</code>表达式来代替它:</p>
<pre class="hljs"><code><div>r := check os.Open(src)
</div></code></pre>
<p>但这只代替了赋值表达式和 if 语句，从之前的例子中我们可以看到，有四行完全相同的代码:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"copy %s %s: %v"</span>, src, dst, err)
</div></code></pre>
<p>它是可以被统一处理的, 于是 Go 在引入<code>check</code>的同时引入了<code>handle</code>语句，官方称之为 handler:</p>
<pre class="hljs"><code><div>handle err {
	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"copy %s %s: %v"</span>, src, dst, err)
}
</div></code></pre>
<p>修改后的代码为:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CopyFile</span><span class="hljs-params">(src, dst <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
	handle err {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"copy %s %s: %v"</span>, src, dst, err)
	}

	r := check os.Open(src)
	<span class="hljs-keyword">defer</span> r.Close()

	w := check os.Create(dst)
	handle err {
		w.Close()
		os.Remove(dst) <span class="hljs-comment">// (only if a check fails)</span>
	}

	check io.Copy(w, r)
	check w.Close()
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</div></code></pre>
<p>check 失败后，error 先被最里层的(inner most)handler 处理，接着被上一个(按照语法顺序)handler 处理，直到某个 handler 执行了<code>return</code>语句。</p>
<p>Go team 对该草案的期望是能够减少错误处理的代码量, 且兼容之前的错误处理方式, 要求不算高，这个设计也算能接受吧。</p>
<p><a href="https://golang.org/wiki/Go2ErrorHandlingFeedback">反馈渠道</a></p>
<h3 id="%E9%94%99%E8%AF%AF%E5%80%BC">错误值</h3>
<p>Go 的错误值目前存在两个问题。一，错误链(栈)没有被很好地表达；二，缺少更丰富的错误输出方式。在该草案之前，已经有不少第三方的 package 实现了这些功能，现在要进行标准化。目前，对于多调用层级的错误，我们使用 fmt.Errorf 或者自定义的 Error 来包裹它:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"io"</span>
)

<span class="hljs-keyword">type</span> RpcError <span class="hljs-keyword">struct</span> {
	Line <span class="hljs-keyword">uint</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *RpcError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"(%d): no route to the remote address"</span>, s.Line)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn3</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">return</span> io.EOF
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> err := fn3(); err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> &amp;RpcError{Line: <span class="hljs-number">12</span>}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> err := fn2(); err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"call fn2 failed, %s"</span>, err)
	}
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">if</span> err := fn1(); err != <span class="hljs-literal">nil</span> {
		fmt.Println(err)
	}
}
</div></code></pre>
<p>此程序的输出为:</p>
<pre class="hljs"><code><div>call fn2 failed, (12): no route to the remote address
</div></code></pre>
<p>很明显的问题是，我们在 main 函数里对 error 进行处理的时候不能进行类型判断, 比如使用 if 语句判断:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> err == io.EOF { ... }
</div></code></pre>
<p>或者进行类型断言:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> pe, ok := err.(*os.PathError); ok { ... pe.Path ... }
</div></code></pre>
<p>它是一个 RpcError 还是 io.EOF? 无从知晓。一大串的错误信息，人类可以很好地理解，但对于程序代码来说就很困难。</p>
<h5 id="error-inspection">error inspection</h5>
<p>草案引入了一个 error wrapper 来包裹错误链, 它相当于一个指针，将错误栈链接起来:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> errors

<span class="hljs-comment">// A Wrapper is an error implementation</span>
<span class="hljs-comment">// wrapping context around another error.</span>
<span class="hljs-keyword">type</span> Wrapper <span class="hljs-keyword">interface</span> {
	<span class="hljs-comment">// Unwrap returns the next error in the error chain.</span>
	<span class="hljs-comment">// If there is no next error, Unwrap returns nil.</span>
	Unwrap() error
}
</div></code></pre>
<p>每个层级的 error 都实现这个 wrapper，这样在 main 函数里，我们可以通过 err.Unwrap() 来获取下一个层级的 error。另外，草案引入了两个函数来简化这个过程:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Is reports whether err or any of the errors in its chain is equal to target.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target error)</span> <span class="hljs-title">bool</span></span>

<span class="hljs-comment">// As checks whether err or any of the errors in its chain is a value of type E.</span>
<span class="hljs-comment">// If so, it returns the discovered value of type E, with ok set to true.</span>
<span class="hljs-comment">// If not, it returns the zero value of type E, with ok set to false.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(<span class="hljs-keyword">type</span> E)</span><span class="hljs-params">(err error)</span> <span class="hljs-params">(e E, ok <span class="hljs-keyword">bool</span>)</span></span>
</div></code></pre>
<h5 id="error-formatting">error formatting</h5>
<p>有时候我们需要将错误信息分类，因为某些情况下你需要所有的信息，某些情况下只需要部分信息，因此草案引入了一个 interface:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> errors

<span class="hljs-keyword">type</span> Formatter <span class="hljs-keyword">interface</span> {
	Format(p Printer) (next error)
}
</div></code></pre>
<p>error 类型可以实现 Format 函数来打印更详细的信息:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *WriteError)</span> <span class="hljs-title">Format</span><span class="hljs-params">(p errors.Printer)</span> <span class="hljs-params">(next error)</span></span> {
	p.Printf(<span class="hljs-string">"write %s database"</span>, e.Database)
	<span class="hljs-keyword">if</span> p.Detail() {
		p.Printf(<span class="hljs-string">"more detail here"</span>)
	}
	<span class="hljs-keyword">return</span> e.Err
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *WriteError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> { <span class="hljs-keyword">return</span> fmt.Sprint(e) }
</div></code></pre>
<p>在你使用<code>fmt.Println(&quot;%+v&quot;, err)</code>打印错误信息时，它会调用 Format 函数。</p>
<p><a href="https://github.com/golang/go/wiki/Go2ErrorValuesFeedback">反馈渠道</a></p>

</body>
</html>
